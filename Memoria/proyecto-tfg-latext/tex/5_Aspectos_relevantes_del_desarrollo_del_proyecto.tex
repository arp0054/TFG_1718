\capitulo{5}{Aspectos relevantes del desarrollo del proyecto}

\section{Conceptos técnicos en las variables. Formato.}

Como habíamos comentado, las variables se almacenaban en las tramas que contenía el fichero.
Cada línea del fichero correspondía a una trama distinta, y las tramas tenían configuraciones distintas dependiendo del contenedor de la trama/variable.\cite{LITTLE}
Por tanto, vemos en un ejemplo, cuáles son los elementos que forman parte:

30 09:58:04:534923 03C 1B00060004110000
\begin{itemize}
	\item 03C es el contenedor de la variable.

	\item 1B00060004110000, es el contenido en hexadecimal y en littleEndian de los datos.

\end{itemize}
A continuación, vamos a especificar como se realiza la extracción de variables entre los distintos tipos.

LittleEndian, “de comienzo por el extremo pequeño”, es una adopción del formato que se almacenan los datos con más de un Byte. 
\imagen{le}{Ejemplo disposición LittleEndian. Fuente https://es.wikipedia.org}

Este sistema hace más efectivo el acceso a datos, efectuándose de manera incremental de menos relevante a más relevante, dando más importancia a como acaban las cosas más que como empiezan. 


Según el fabricante los datos se guardan en LittleEndian o BigEndian, aunque estos 2 no son los únicos formatos.


En el caso de este proyecto nos basaremos únicamente en LittleEndian.


En este ejemplo si tendríamos un entero de unsigned de 32 bits (cogeriamos los primeros 32 bits) se distrubiría de la siguiente forma.

\begin{itemize}
	\item 1B000600 : Formato hexadecimal.

	\item 00, 06, 00, 1B: En littleEndian.

\end{itemize}


Una vez que tenemos los datos en littleEndian, procederiamos a traducir a decimal este valor, el cual puede ser traducido directamente gracias a javascript.
\begin{itemize}
	\item En binario: 0000 0000 0000 0110 0000 0000 0001 1011

	\item En decimal:  393243

\end{itemize}

Un caso más complejo sería si en vez de unsigned, fuese signed. 

Entonces tenemos que tener en cuenta el complemento a 2 en binario de dato antes de pasarlo a decimal.

 
\section{Fallos del datalogger}



Realizando este proyecto, nos percatamos que los datos dentro del datalogger a veces fallaban.
Ya que algunas gráficas como resultados daban picos anómalos que no tenían sentido.
Estos fueron los datos que nos hicieron percatarnos de esto:
30 09:58:59:999999
30 09:58:50:002123
Lo que ocurría es que el segundero, minutero y el contador de las horas del archivo generador de tramas no estaban incrementando bien, ya que estaba varios relojes del sistema, y fallaba cuando tenía que incrementar, sucediendo solo en los casos en los que los microsegundos tendían a 0 (Observamos distintos casos).
Por lo tanto, tuvimos que realizar una función para reparar esos datos y que no se perdiesen esas tramas, puesto que algún dato podía ser crítico. (Despreciamos los errores que surgían justo en el cambio de día, al tratarse de un error muy puntual)

\section{Analizador del XML en JavaScript}


Para este proyecto, tuvimos que implementar el analizador de XML,de JavaScript, con el XML DOM. La tarea no fue sencilla ya que el analizador recogía basura, del DOM, en las raíces de cada nodo, y tuvimos que rechazarla. De hecho, nuestro XML, no acepta comentarios, porque suponía una dificultad extra al proyecto, aunque se marcará como posible mejora



La sintaxis era la siguiente \cite{DOMPARSER}
Para invocar al analizador:


\imagen{parserXML}{Sintáxis del analizador XML en javascript}



Decidimos guardar la estructura en un objeto una vez parseado el objeto, para dar flexibilidad al código.











\section{Complejidad extracción biblioteca}

Una de las decisiones que tomamos fue extraer todos los datos en la biblioteca, en vez de ir cargando una a una, las variables según lo pidieran los usuarios.
Esta decisión tiene sus ventajas e inconvenientes:
Ventajas:
Una vez realizada la primera carga, el usuario podrá cargar distintas variables, sin que tenga que realizar ninguna nueva carga, de forma que irá mucho más fluido.
Inconvenientes:
Mayor uso de memoria.
Se realizará una carga completa de todas las variables de los ficheros, por lo que la primera carga durará más


Complejidad algorítmica de la creación de la biblioteca:

\begin{itemize}
	\item Recorrer ficheros seleccionados (numero ficheros seleccionados)
	\item Recorrer cada trama de ese fichero (numero ficheros seleccionados * lineas fichero).	
	\item Utilizar configuración para extracción de esa trama en concreto (numero ficheros seleccionados * lineas fichero * distintas configuraciones XML)
	
	\item Recorrer la cadena de caracteres para sacar los datos de dichas variables (numero ficheros seleccionados * lineas fichero * distintas configuraciones XML * numero de caracteres trama)

\end{itemize}


\section{Conector gráfica-biblioteca}

Una vez obtenidos todos los datos, teníamos que dejar las colecciones de forma que las librerías de gráficos pudieran trabajar con esos datos.

Para conectar estos datos tenemos en cuenta los 2 tipos de gráfica:
\begin{itemize}
	\item En la gráfica temporal, creamos un diccionario como clave: la hora, y valor: el valor numérico de dicha variable, junto la hora otra vez.
Es necesario tener un campo adicional para la hora, pues creamos un diccionario para ordenar los valores por fecha (a la librería los datos tenian que ir ordenados).
Una vez ordenados estos valores, la clave que recorremos no la reconoce como un objeto tipo fecha, sino como un string, por lo que la herramienta gráfica no reconoce.

	\item En la gráfica XY: Como en el caso anterior tenemos que ordenar los datos por su fecha, tanto para el valor x como para el valor y.
Una vez que ordenamos las fechas, tenemos que sincronizar los 2 valores (el valor x, y el valor y). La forma de sincronización es la siguiente:
Si tenemos unos instantes de tiempo para la variable del eje x {1,3,5,6,10}
Si tenemos unos instantes de tiempos para la variable del eje y {4,5,6,8}
La sincronización se realizará cuando se dispongan ambas variables en el instante de tiempo, en este caso, en el segundo 4 tendremos las variables de x del segundo 3 (hasta el segundo 5 no cambia de valor, por lo tanto, mantiene el valor del segundo 3).
Por cada instante de tiempo del valor x, y una vez sincronizadas: tendremos un nuevo valor para la gráfica X-Y.
.
\end{itemize}


\section{Diezmados}

Para un correcto funcionamiento del navegador, los puntos totales mostrados en la gráfica tienen que estar acotados en un máximo, es decir, el navegador no puede ir fluido graficando un número elevado de puntos en un canvas.

Por ello marcamos un máximo de puntos, en cada gráfica.

La característica especial de nuestra herramienta, es que siempre vamos a trabajar con los datos en bruto, por lo que, si se realiza un zoom o una búsqueda, los datos mostrados se recalcularán con diezmados por lo que, si en un principio tenemos 10000 datos entre los segundos 1 y 10, con 1000 datos por segundos. En principio haríamos un diezmado de los 10000 datos, es decir, graficaríamos 1 punto por cada (10000/ {puntos máximos diezmado}).

Si haríamos un zoom entre los segundos 3, 4, realizaríamos un diezmado de nuevo entre esos 1000 datos, (1 punto por cada (1000/ {puntos máximos diezmado})) por lo que es posible que se muestren nuevos picos/puntos que a priori no podíamos ver, ya que habían sido diezmados.

Los diezmados tienen en cuenta las demás variables, y son repartidos equitativamente, de tal manera que siempre se respetará el máximo de puntos graficados.


\section{Gráfica temporal/maestra}

Debajo de cada gráfica temporal, hemos realizado una gráfica maestra, que será utilizada como mapa conceptual con un diezmado más elevado que la superior. En esta gráfica hemos añadido distintas funcionalidades, todas ellas, funcionalidades que no existían en la librería de gráficos utilizada:
\begin{itemize}
	\item Un cuadro de zoom, en la cual, obtendremos información de que datos coger en la gráfica principal y que diezmado aplicar.

	\item Distintas operaciones con el cuadro de zoom.

	\item Simulación de eventos de click, para obtener el punto más cercano dentro de la gráfica y poder utilizarla por ejemplo para marcar límites del zoom.

	\item Una reproducción, gracias a jQuery, y forzando el sincronismo, observamos la animación de cómo se mueve el cuadro de zoom, pudiendo incrementar/aminorar la reproducción.

\end{itemize}



\section{Búsquedas y filtros}

Para calcular las búsquedas y filtros, hemos creado una gramática gracias a JavaScript que sigue la siguiente sintaxis.
Tokens:
\begin{itemize}
	\item Variable=nombre de la variable
	\item Valor = valor número que queremos comparar
	\item Comparador $(==,=,!=,>,>,>=,<=)$
	\item Conector (AND, and, OR, or)
\end{itemize}


Sintaxis:
\begin{itemize}
\item Variable comparador valor $[$conector variable comparador valor$]*$
\end{itemize}
(Entre corchetes $[]$, opcional, no admite paréntesis)

Esta sintaxis lo que hace es obtener los intervalos de los tiempos en los que se cumplen, de la forma más óptima posible de tal manera que estos intervalos son aprovechados para los filtros o búsquedas.

\section{Idioma}

El idioma escogido para la interfaz de usuario ha sido el inglés, puesto que es el idioma más internacional del mundo.
El código del proyecto está en español, puesto que es el lenguaje nativo del programador.
Se estudió aplicar internacionalización de la página web, pero se descartó, en primer lugar, porque con un conocimiento básico del inglés la herramienta se domina perfectamente, y entendemos que la gente que puede usar esta herramienta tiene conocimientos del idioma, y, en segundo lugar, porque requería mucho trabajo y se escapaba dentro de los Springs del proyecto.

\section{Patrón decorador}

Hemos utilizado este patrón de diseño para la interfaz gráfica de las vistas (opciones de gráfica, opciones variables) de tal modo que implementábamos a un modal funcionalidades de forma dinámica (objeto del DOM), de tal manera que reutilizábamos el objeto, extendiendo o quitando funcionalidades. \cite{DECORATOR}
\imagen{decotador}{Ventana gráfica en la que hemos utilizado este patrón.}


 
\section{Single-page application}
Al tratarse de una herramienta de trabajo, hemos considerado que la mejor opción respecto al diseño era el formato single-page application.
Esto lo hemos conseguido a través de inyecciones de HTML mediante JavaScript, y utilización de spinners para marcar las transacciones entre ventanas, dando la sensación que más de una página web estamos trabajando en una herramienta.
Aunque teníamos la opción de trabajar con estados gracias la API de HTML5, permitiendo navegabilidad en páginas lógicas.

\imagen{spa}{Página de inicio SPA.}

Como se observa el la imagen, de principio a fin la página no realiza ninguna transacción entre ninguna página.
Como contra a este método, podemos decir, que el código se ensuciaba con estas inyecciones de html mediante JavaScript, pero el resultado de la parte funcional es satisfactorio.
Respecto al rendimiento, también es la mejor opción, pues la transferencia de ficheros es bastante lenta desde el datalogger , y teniendo este tipo de diseño conseguimos que una vez cargada, la página vaya fluida para el usuario de principio a fin.



\section{Comparativa herramienta de graficado Chart.js con funcionalidad final del proyecto}

Funcionalidades de Chart.js con el plugin annotations
\begin{itemize}
	\item Actualizar gráfica en vivo
	\item Dibujar líneas y cuadrados en la gráfica conociendo el tiempo
	\item Graficar en el tiempo con conjuntos ordenados en el tiempo.
	\item Modificar aspectos de la gráfica (color, tamaño, etc)
	\item Graficar coordenadas X, Y.
	\item Desdibujar a tiempo real variables mediante la leyenda.
\end{itemize}



Funcionalidades del proyecto realizado.
\begin{itemize}
	\item Actualizar gráfica en vivo
	\item Dibujar líneas y cuadrados en la gráfica conociendo el tiempo
	\item Graficar en el tiempo con conjuntos ordenados en el tiempo.
	\item Modificar aspectos de la gráfica (color, tamaño, etc)
	\item Graficar coordenadas X, Y
	\item Desdibujar a tiempo real variables mediante la leyenda.
	\item Ventana temporal/ maestra de la dibujada.
	\item Zoom horizontal visualizando un mapa conceptual del total.
	\item Reproducción de la gráfica.
	\item Dibujar tiempos temporales incluso cuando están desordenados.
	\item Dibujar cursores haciendo click en la ventana de la gráfica
	\item Calcular puntos reales de la gráfica que corta el cursor.
	\item Búsqueda de puntos dentro de la gráfica.
	\item Filtro en la gráfica.
\end{itemize}


